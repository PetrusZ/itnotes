[TOC]

# shell简介

Shell 是一个用 C 语言编写的程序，Shell 既是一种命令语言，又是一种程序设计语言。Shell 是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。

Ken Thompson 的 sh 是第一种 Unix Shell，Windows Explorer 是一个典型的图形界面 Shell。

**Shell 脚本（shell script）**，是一种为 shell 编写的脚本程序。

**Shell环境**:运行shell脚本的环境。

shell分类：

 - Bourne：常见的是sh(Bourne Shell)和bash(Bourne Again Shell)，还有fish、zsh等等
 - C：cshell、tcsh（BSD的Unix)

以下以bash为默认shell。

- shell查看

```shell
echo $SHELL    #查看当前使用的shell
cat /etc/shells    #查看当前系统支持的shell
```

- 执行脚本
  - 脚本需要有执行权限：`chmod +x file`
  - 运行方法：`./file.sh`或`bash file.sh`

- 命令别名alias
  `alias ll='ls -al --color=auto'`  -使用ll别名替代`ls -al --color=auto`这条命令。
  可以在`~/.bashr`中使用alias设置别名，使得该别名在当前用户下一直生效。添加别名后，使用`source ~/.bashrc`可使其立即生效。
  命令优先级顺序：绝对/相对路径执行命令>**别名>bash内部命令>**$PATH环境变量定义的目录查找顺序的第一个命令

# shell基础

## 基本规则

- 扩展名sh：脚本文件可以不使用扩展名，但是使用扩展名sh，shell可以为代码提供颜色高亮。
- 解释器：在脚本文件开始时使用类似`#!/bin/sh`指定解释器。
- 单引号`''`：引号内的**所有字符**都只是普通字符。
- 双引号`""`： 除了`$`和`\`之外的字符均无特殊含义。
- `：反引号，反引号内部的内容是系统命令。
- `$()`：和反引号作用一样，内部的内容是系统命令。
- `#`：注释符号。
- `$`：放在变量名前用于**调用变量**的值。

## read输入

选项：

- -p   提示信息
- -t    等待时间（单位：秒）
- -n   指定接收输入的字符数
- -s    不显示输入的数据，用于机密信息的输入（如密码）

```shell
read -p "please input username:"
read -s -p "please input password:"
```



## echo输出

选项：

-  **-n** 不要在最后自动换行
-  -e   控制符支持

echo 输入内容，-e选项可支持控制字符（见下表），输出的内容最好加上引号，否则在某些情况下会出问题（如使用空格、控制符号等的时时候）。
```shell
echo a  #输出test
echo a\nb    #输出anb
echo -e   "a\nb"    #输出a (换行) b 
```

### 控制符

|   控制字符   |         意义         |
| :------: | :----------------: |
|    \a    |        警告声         |
|    \b    |   退格键-backspace    |
|    \n    |   换行符-next line    |
|    \r    |     回车键-return     |
|    \t    |      制表符-tab       |
|    \v    | 垂直制表符-vertical tab |
|  \0nnn   |  八进制数(nnn表示八进制数)   |
|   \xhh   |  十六进制数(hh表示十六进制数)  |
| \e[1;31m |  1--高亮显示，31m--红色   |
|  \e[0m   |       0使用默认值       |

样式：0（默认值）、1（高亮）、22（非粗体）、4（下划线）、24（非下划线）、5（闪烁）、25（非闪烁）、7（反显）、27（非反显）   

颜色：

- 前景色：30m黑色  31m红色  32m绿色  33m黄色  34m蓝色  35m洋红  36m青色 37m白色。

- 背景色：40m黑色  41m红色  42m绿色  43m黄色  44m蓝色  45m洋红  46m青色 47m白色。

 使用示例：`echo -e \e[1;35m文字文字\e[0m`  效果是以洋红色高亮显示“文字文字”

## 重定向
在 shell的命令执行的过程中，主要有三种输出入的状况，分别是：
1. 标准输入-键盘；代码为 0 ；或称为 stdin ；使用的方式为 `<`
2. 标准输出-显示器：代码为 1 ；或称为 stdout；使用的方式为 `1>`
3. 错误输出-显示器：代码为 2 ；或称为 stderr；使用的方式为 `2>`
| 说明                             | 命令              |
| :----------------------------- | :-------------- |
| 将输出重定向到 file。                  | command > file  |
| 将输入重定向到 file。                  | command < file  |
| 将输出以追加的方式重定向到 file。            | command >> file |
| 将文件描述符为 n 的文件重定向到 file。        | n > file        |
| 将文件描述符为 n 的文件以追加的方式重定向到 file。  | n >> file       |
| 将输出文件 m 和 n 合并。                | n >& m          |
| 将输入文件 m 和 n 合并。                | n <& m          |
| 将开始标记 tag 和结束标记 tag 之间的内容作为输入。 | << tag          |

如果希望执行某个命令，但又不希望在屏幕上显示输出结果:
- `command > /dev/null`   - /dev/null是一个空文件
- `command > /dev/zero`   -/dev/zero是一个无显示的无限输入文件

错误重定向相关
- `2>`      将一个标准错误输出重定向到一个文件或设备 **覆盖**原来的文件
- `2>>`    将一个标准错误输出重定向到一个文件或设备 **追加**到原来的文件
- `2>&1`    将一个**标准错误输出重定向到标准输出**
- `|&`     将一个标准错误 管道 输送 到另一个命令作为输入
- `&>>`    以**追加的方式把正确输出和错误输出都保存**到同一个文件中
- `&>`以**覆盖的方式把正确输出和错误输出都保存**到同一个文件中

## 多命令执行
### 逻辑符
- `; `  分号-- `a;b`   各命令间没有逻辑关系影响
- `&& `   逻辑与--`a&&b`    前面的命令正确执行，才能执行后面的命令
- `||`    逻辑或--`a||b`    前面的命令不能正确执行，就执行后面的命令
### 管道符
`|`  -- `a|b`    前面命令的**正确输出**作为命令B的操作对象。

## 通配符

- `?`    匹配任意内容（0个或多个字符）
- `*`    匹配一个字符
- `[]`    匹配括号内任意一个字符（如`[ab]`匹配a或b或c）
  - `[-]`   匹配在编码顺序内的所有字符（如`[a-z]`匹配a到z的字母）
  - `[!]`    匹配**除了**`!`后面字符的其他字符（如`[!abc]`匹配除了abc的字符）


# 变量
定义变量时，变量名不加`$`符号，使用变量是需要加`$`在变量名前。`unset 变量名`可删除变量。

## 变量分类

`set`可以查询所有已经存在的变量，`set name`查找名为name的变量

- **用户自定义**变量
- 环境变量：保存和系统环境相关的数据；对系统生效的环境变量名和变量作用是固定的。`env`可查询当前环境变量。
- 预定义变量：shell中（如bash中）已经定义好的变量，变量名不能自定义，变量作用固定。
  - 位置参数变量：向脚本中传递参数或数据，变量名不能自定义，变量作用固定。

---

### 环境变量
主要的几个环境变量配置文件：
>/etc/profie
>/etc/profile.d/*
>~/.bash_profile
>~/.bashrc
>/etc/bashrc

  配置文件修改后立即生效，使用source，示例

```shell
source ~/.bashrc
#或者
. ~/.bashrc
```

#### 登录提示信息

- /etc/issue显示**本地登录**提示信息

  | 转义符  | 说明    |
  | ---- | ----- |
  | \d   | 日期    |
  | \t   | 时间    |
  | \l   | 终端号   |
  | \u   | 用户序列号 |
  | \m   | 硬件架构  |
  | \n   | 主机名   |
  | \o   | 域名    |
  | \r   | 内核版本  |
  | \s   | 系统名称  |

- /etc/issue.net显示**远程登录**提示信息

  登录成功前显示（连接上服务器后立即显示）

  需要在/etc/ssh/ssh_config配置文件中有`Banner /etc/issue.net`。不支持转义字符。

- /etc/motd

  登录成功后显示

### 预定义变量

| $?   | 最后一次执行的命令的返回状态（0-执行正确，1-执行错误） |
| ---- | ----------------------------- |
| $$   | 当前进程号（PID）                    |
| $!   | 后台运行的最后一个进程的进程号（PID）          |

#### 位置参数变量

| 位置参数变量 | 作用                                 |
| :----- | :--------------------------------- |
| $n     | n为数字，0代表命令行本身,第10个参数以上要用大括号`${10}` |
| $*     | **所有参数**，把所有参数视为一个整体               |
| $@     | **所有参数**，把所有参数区分对待                 |
| $#     | 所有参数的个数                            |

- 变量名命名规则：

  - **首个字符必须为字母**（a-z，A-Z）。
  - 中间不能有空格，可以使用下划线（_）。
  - **不能使用标点符号**。
  - 不能使用shell里的关键字（可用help命令查看保留关键字）。

- 变量定义和使用

  ```shell
  var=value    #定义变量
  echo $var    #使用变量
  ```

  - 所有变量的值实际都是字符串。
  - 定义变量时，**等号两边不能有空格**。
  - 重复定义变量，后面的赋值会覆盖前面的赋值。

## declare声明变量类型
用于变量类型声明。如不声明，变量默认类型是字符串。
选项：
- `-`    给变量设定类型属性
- `+`    取消变量的类型属性
- -a    将变量声明为**数组**型
- -i     将变量声明为**整数**型
- -x    将变量声明为**环境变量**
- -r    将变量声明为**只读**类型
- -p    **显示**指定变量的被声明的**类型**
- -f     仅显示函数

# 运算
shell运算符包括：算数运算符、关系运算符、布尔运算符、字符串运算符和文件测试运算符。

**运算符两侧要有空格。**

## 关系运算符

|  符号  | 说明                            | 举例                      |
| :--: | :---------------------------- | :---------------------- |
| -eq  | 检测两个数是否相等，相等返回 true。          | `[$a -eq $b]`返回false。   |
| -ne  | 检测两个数是否相等，不相等返回 true。         | `[$a -ne $b ]`返回true。   |
| -gt  | 检测左边的数是否大于右边的，如果是，则返回 true。   | `[ $a -gt $b ]`返回false。 |
| -lt  | 检测左边的数是否小于右边的，如果是，则返回 true。   | `[$a -lt $b]`返回 true。   |
| -ge  | 检测左边的数是否大于等于右边的，如果是，则返回 true。 | `[$a -ge $b]` 返回 false。 |
| -le  | 检测左边的数是否小于等于右边的，如果是，则返回 true。 | `[$a -le $b]`返回true。    |

## 数值运算

shell变量默认类型为字符串，可使用以下方法进行数值运算（主要是整数运算）。

- $(())表达式
```shell
a=1
b=2
c=$(($a+$b))
```



- declare
  声明变量类型为整数，以进行运算：
```shell
a=1
declare -i c = $a + 1
echo c    #c为2
```

- expr工具

  `expr 运算式`：（附expr的常用操作）

```shell
expr 100%11    #1  整数运算
expr length "string"    #6  字符串长度
expr substr "this-string" 3 5    #is  在[3,5)区间查找字符串
expr index "string" s   #1  s第一次出现的位置
```

- let工具

   `let 运算式`：

```shell
let a=1+1    #a为2
let a++	   #a为3
let a-=2    #a为1
echo $a   # 1
```

## 变量测试

| 变量置换方式     | 变量y没有设置    | 变量y为空值     | 变量         |
| ---------- | ---------- | ---------- | ---------- |
| x=${y-新值}  | x=新值       | x为空        | x=$y       |
| x=${y:-新值} | x=新值       | x=新值       | x=$y       |
| x=${y+新值}  | x为空        | x=新值       | x=新值       |
| x=${y:+新值} | x为空        | x为空        | x=新值       |
| x=${y=新值}  | x=新值  y=新值 | x为空  y值不变  | x=$y  y值不变 |
| x=${y:=新值} | x=新值  y=新值 | x=新值  y=新值 | x=$y  y值不变 |
| x=${y?新值}  | 新值（标准错误）输出 | x值为空       | x=$y       |
| x=${y:?新值} | 新值（标准错误）输出 | 新值（标准错误）输出 | x=$y       |

# 正则表达式

**正则表达式与通配符**：

正则表达式是**包含匹配**，用于**文件内容**匹配；通配符是**完全匹配**，多用于**文件名**匹配。

- 支持正则：grep 、cut、sort、awk、sed、uniq
- 只支持通配符不支持正则：find、cp、ls、rm

参看正则表达式和相关工具文档。

# 流程控制

## 条件判断
### 文件类型判断
`-option file`根据各选项，判断文件的某种情况，返回true或false。
|  选项  | 说明                       |
| :--: | ------------------------ |
|  -b  | 判断文件是否存在，且是否为**块设备**文件   |
|  -c  | 判断文件是否存在，且是否为**字符设备**文件  |
|  -d  | 判断文件是否存在，且是否为**目录**文件    |
|  -e  | 判断文件是否存在                 |
|  -f  | 判断文件是否存在，且是否为**普通**文件    |
|  -L  | 判断文件是否存在，且是否为块**符号链接**文件 |
|  -p  | 判断文件是否存在，且是否为**管道**文件    |
|  -s  | 判断文件是否存在，且是否为非空          |
|  -S  | 判断文件是否存在，且是否为**套接字**文件   |

### 文件权限判断
`-option file`根据各选项，判断某项权限的情况，返回true或false。
|  选项  | 说明                  |
| :--: | ------------------- |
|  -r  | 判断文件是否存在，且是否有读权限    |
|  -w  | 判断文件是否存在，且是否有写权限    |
|  -x  | 判断文件是否存在，且是否有执行权限   |
|  -u  | 判断文件是否存在，且是否有SUID权限 |
|  -g  | 判断文件是否存在，且是否有SGID权限 |
|  -k  | 判断文件是否存在，且是否有SBit权限 |
### 文件对比判断
`file1 -option file2`根据各选项，将第一个文件和第二个文件对比，判断对比情况，返回true/false。
|  选项  | 说明                       |
| :--: | ------------------------ |
| -nt  | 判断文件修改时间是否更新             |
| -ot  | 判断文件修改时间是否更晚             |
| -ef  | 判断文件的Inode是否一致（一致则为同一文件） |
### 整数对比判断
`num1 [-option] num2`根据各选项，将第一个数和第二个数对比，判断对比情况，返回true/false。
|  选项  | 说明                              |
| :--: | ------------------------------- |
| -eq  | 判断是否相等（equal）                   |
| -ne  | 判断是否不等（not equal）               |
| -gt  | 判断是否更大（greater than）            |
| -lt  | 判断是否更小（less than）               |
| -ge  | 判断是否大于等于（greater than or equal） |
| -le  | 判断是否小于等于（less than or equal）    |
### 字符串判断
空和非空：`-option string` ；等和不等`string1 -option string2`
根据各选项判断字符串情况，返回true或false。
|  选项  | 说明     |
| :--: | ------ |
|  -z  | 判断是否为空 |
|  -n  | 判断是否非空 |
|  ==  | 判断是否相等 |
|  !=  | 判断是否不等 |
### 多重条件判断
逻辑或和逻辑与：` expression1 -a expression2`;逻辑非：`!  expression`。
根据选项，进行判断逻辑情况，返回true或false。
|  选项  | 说明   |
| :--: | ---- |
|  -a  | 逻辑与  |
|  -o  | 逻辑或  |
|  !   | 逻辑非  |

## 分支
- 单分支

写法示例：

```shell
if [expression]; then
	#some codes
fi
#或者
if [expression]
then
	#some codes
fi
```
- 双分支

写法示例：

```shell
if [expression]
then
	#some codes
else
	#some codes
fi
```
- 多分支
  - 多分支if

  ```shell
  if [expression]
  then
  	#some codes
  elif
  then
  	#some codes
  else
  	#some codes
  fi
  ```

  ​

  - 多分支case

  ```shell
  case var in
  "value1")
  	#some codes
  	;;
  "value2")
  	#some codes
  	;;
  "*")    #最后一个默认分支使用*
  	#some codes
  ;;
  esac
  ```

## 循环

- for循环


```shell
for var in value1 value2 value3
#for var in $("string")
#for var in $(cat testfile)
#也可以这样写，注意：shell中不能写诸如i+=1或i++
#for ((i=1;i<=100;i=i+1))
do
	#some codes
done
```

- while循环


  expression中条件为真时进行循环。

```shell
while(expression)
do
	#some codes
done
```

- util循环

  expression中条件为**假**时进行循环，与while相反。


```shell
util expression
do
	#some codes
done
```