[TOC]

# shell简介

Shell 是一个用 C 语言编写的程序，Shell 既是一种命令语言，又是一种程序设计语言。Shell 是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。

Ken Thompson 的 sh 是第一种 Unix Shell，Windows Explorer 是一个典型的图形界面 Shell。

**Shell 脚本（shell script）**，是一种为 shell 编写的脚本程序。

**Shell环境**:运行shell脚本的环境。

shell分类：

 - Bourne：常见的是sh(Bourne Shell)和bash(Bourne Again Shell)，还有fish、zsh等等
 - C：cshell、tcsh（BSD的Unix)

以下以bash为默认shell。

- shell查看

```shell
echo $SHELL    #查看当前使用的shell
cat /etc/shells    #查看当前系统支持的shell
```

- 执行脚本
  - 脚本需要有执行权限：`chmod +x file`
  - 运行方法：`./file.sh`或`bash file.sh`

- 命令别名alias

  示例：`alias ll='ls -al --color=auto'`  使用ll别名替代`ls -al --color=auto`这条命令，仅临时生效。可以在`~/.bashr`中使用alias设置别名，使得该别名在当前用户下一直生效。添加别名后，使用`source ~/.bashrc`可使其立即生效。

- 命令优先级顺序：绝对/相对路径执行命令>**别名>bash内部命令>**$PATH环境变量定义的目录查找顺序的第一个命令

# shell基础

## 基本规则

- 扩展名sh：脚本文件可以不使用扩展名，但是使用扩展名sh，shell可以为代码提供颜色高亮。
- 解释器：在脚本文件开始时使用类似`#!/bin/sh`指定解释器。
- 单引号`''`：引号内的**所有字符**都只是普通字符。
- 双引号`""`： 除了`$`和`\`之外的字符均无特殊含义。
- `：反引号，反引号内部的内容是系统命令。
- `$()`：和反引号作用一样，内部的内容是系统命令。
- `#`：注释符号。
- `$`：放在变量名前用于**调用变量**的值。

## read输入

选项：

- -p   提示信息
- -t    等待时间（单位：秒）
- -n   指定接收输入的字符数
- -s    不显示输入的数据，用于机密信息的输入（如密码）

```shell
read -p "please input username:"
read -s -p "please input password:"
read -p "请输入名字：" name  #将用户的输入内容赋值给name变量
```

## 输出

### echo

选项：

-  **-n** 不要在最后自动换行
-  -e   控制符支持

echo 输入内容，-e选项可支持控制字符（见下表），输出的内容最好加上引号，否则在某些情况下会出问题（如使用空格、控制符号等的时时候）。
```shell
echo a  #输出test
echo a\nb    #输出anb
echo -e   "a\nb"    #输出a (换行) b
```

#### 控制符

|   控制字符   |         意义         |
| :------: | :----------------: |
|    \a    |        警告声         |
|    \b    |   退格键-backspace    |
|    \n    |   换行符-next line    |
|    \r    |     回车键-return     |
|    \t    |      制表符-tab       |
|    \v    | 垂直制表符-vertical tab |
|  \0nnn   |  八进制数(nnn表示八进制数)   |
|   \xhh   |  十六进制数(hh表示十六进制数)  |
| \e[1;31m |   1--高亮显示，31--红色   |
|  \e[0m   |     恢复默认样式和颜色      |

样式：1（高亮）、22（非粗体）、4（下划线）、24（非下划线）、5（闪烁）、25（非闪烁）、7（反显）、27（非反显）

颜色：

- 前景色：30黑色  31红色  32绿色  33黄色  34蓝色  35洋红  36青色 37白色

- 背景色：40黑色  41红色  42绿色  43黄色  44蓝色  45洋红  46青色 47m白色

在样式或者颜色之后要使用m，如`1m`，如果使用颜色和样式，二者以`;`分隔，只在第二个数字后写上m即可。例如：`echo -e '\e[1;35m文字文字\e[0m'`

### printf

printf 命令模仿 C 程序库（library）里的 printf() 程序，使用printf的脚本比使用echo移植性好。

语法：

```
printf  format-string  [arguments...]
```

默认printf不会像 echo 自动添加换行符，需要手动添加 `\n`。

```shell
$ printf "Hello, Shell\n"
Hello, Shell
```

参数：

- format-string： 为格式控制字符串
- arguments：为参数列表。

```shell
#!/bin/sh
printf "%-10s %-8s %-4s\n" 姓名 性别 身高
printf "%-10s %-8s %-4.2f\n" 人甲 男 177.7 
printf "%-10s %-8s %-4.2f\n" 人乙 女 168.8 
```

将输出

```shell
姓名     性别   身高
人甲     男      177.7
人乙     女      168.8
```

## 重定向

在 shell的命令执行的过程中，主要有三种输出入的状况，分别是：
1. 标准输入-键盘；代码为 0 ；或称为 stdin ；使用的方式为 `<`
2. 标准输出-显示器：代码为 1 ；或称为 stdout；使用的方式为 `1>`
3. 错误输出-显示器：代码为 2 ；或称为 stderr；使用的方式为 `2>`
| 说明                             | 命令              |
| :----------------------------- | :-------------- |
| 将输出重定向到 file。                  | command > file  |
| 将输入重定向到 file。                  | command < file  |
| 将输出以追加的方式重定向到 file。            | command >> file |
| 将文件描述符为 n 的文件重定向到 file。        | n > file        |
| 将文件描述符为 n 的文件以追加的方式重定向到 file。  | n >> file       |
| 将输出文件 m 和 n 合并。                | n >& m          |
| 将输入文件 m 和 n 合并。                | n <& m          |
| 将开始标记 tag 和结束标记 tag 之间的内容作为输入。 | << tag          |

如果希望执行某个命令，但又不希望在屏幕上显示输出结果:
- `command > /dev/null`   - /dev/null是一个空文件
- `command > /dev/zero`   -/dev/zero是一个无显示的无限输入文件

错误重定向相关
- `2>`      将一个标准错误输出重定向到一个文件或设备 **覆盖**原来的文件
- `2>>`    将一个标准错误输出重定向到一个文件或设备 **追加**到原来的文件
- `2>&1`    将一个**标准错误输出重定向到标准输出**
- `|&`     将一个标准错误 管道 输送 到另一个命令作为输入
- `&>>`    以**追加的方式把正确输出和错误输出都保存**到同一个文件中
- `&>`以**覆盖的方式把正确输出和错误输出都保存**到同一个文件中

## 多命令执行
### 逻辑符
- `; `  分号-- `a;b`   各命令间没有逻辑关系影响
- `&& `   逻辑与--`a&&b`    前面的命令正确执行，才能执行后面的命令
- `||`    逻辑或--`a||b`    前面的命令不能正确执行，就执行后面的命令
### 管道符
`|`  -- `a|b`    前面命令的**正确输出**作为命令B的操作对象。

## 通配符

- `?`    匹配任意内容（0个或多个字符）
- `*`    匹配一个字符
- `[]`    匹配括号内任意一个字符（如`[ab]`匹配a或b或c）
  - `[-]`   匹配在编码顺序内的所有字符（如`[a-z]`匹配a到z的字母）
  - `[!]`    匹配**除了**`!`后面字符的其他字符（如`[!abc]`匹配除了abc的字符）

# 变量
定义变量时，变量名不加`$`符号，使用变量是需要加`$`在变量名前。`unset 变量名`可删除变量。

Shell函数的变量**默认是全局变量**（无论这个变量是在什么位置），可以被使用`local`关键字定义局部变量，其作用域局限于函数内。

## 变量分类

`set`可以查询所有已经存在的变量，`set name`查找名为name的变量

- **用户自定义**变量
- 环境变量：保存和系统环境相关的数据；对系统生效的环境变量名和变量作用是固定的。`env`可查询当前环境变量。
- 预定义变量：shell中（如bash中）已经定义好的变量，变量名不能自定义，变量作用固定。
  - 位置参数变量：向脚本中传递参数或数据，变量名不能自定义，变量作用固定。

---

### 环境变量
主要的几个环境变量配置文件：

- /etc/profie
- /etc/profile.d/*
- ~/.bash_profile
- ~/.bashrc
- /etc/bashrc

配置文件修改后立即生效，使用source，示例

```shell
source ~/.bashrc
#或者
. ~/.bashrc
```

#### 登录提示信息

- /etc/issue显示**本地登录**提示信息

  | 转义符  | 说明    |
  | ---- | ----- |
  | \d   | 日期    |
  | \t   | 时间    |
  | \l   | 终端号   |
  | \u   | 用户序列号 |
  | \m   | 硬件架构  |
  | \n   | 主机名   |
  | \o   | 域名    |
  | \r   | 内核版本  |
  | \s   | 系统名称  |

- /etc/issue.net：**远程登录**提示信息

登录成功前显示（连接上服务器后立即显示）。需要在/etc/ssh/ssh_config配置文件中有`Banner /etc/issue.net`。不支持转义字符。

- /etc/motd：登录成功后显示

### 预定义变量

| $?   | 最后一次执行的命令的返回状态（0-执行正确，1-执行错误） |
| ---- | ----------------------------- |
| $$   | 当前进程号（PID）                    |
| $!   | 后台运行的最后一个进程的进程号（PID）          |

#### 位置参数变量

| 位置参数变量 | 作用                                 |
| :----- | :--------------------------------- |
| $n     | n为数字，0代表命令行本身,第10个参数以上要用大括号`${10}` |
| $*     | **所有参数**，把所有参数视为一个整体               |
| $@     | **所有参数**，把所有参数区分对待                 |
| $#     | 所有参数的个数                            |

- 变量名命名规则：

  - **首个字符必须为字母**（a-z，A-Z）。
  - 中间不能有空格，可以使用下划线（_）。
  - **不能使用标点符号**。
  - 不能使用shell里的关键字（可用help命令查看保留关键字）。

- 变量定义和使用

  ```shell
  var=value    #定义变量
  echo $var    #使用变量
  ```

  - 所有变量的值实际都是字符串。
  - 定义变量时，**等号两边不能有空格**。
  - 重复定义变量，后面的赋值会覆盖前面的赋值。

## declare声明变量类型
用于变量类型声明。如不声明，变量默认类型是字符串。
选项：
- `-`    给变量设定类型属性
- `+`    取消变量的类型属性
- -a    将变量声明为**数组**型
- -i     将变量声明为**整数**型
- -x    将变量声明为**环境变量**
- -r    将变量声明为**只读**类型
- -p    **显示**指定变量的被声明的**类型**
- -f     仅显示函数

# 运算
shell运算符包括：算数运算符、关系运算符、布尔运算符、字符串运算符和文件测试运算符。

**运算符两侧要有空格。**

## 关系运算符

|  符号  | 说明                            | 举例                      |
| :--: | :---------------------------- | :---------------------- |
| -eq  | 检测两个数是否相等，相等返回 true。          | `[$a -eq $b]`返回false。   |
| -ne  | 检测两个数是否相等，不相等返回 true。         | `[$a -ne $b ]`返回true。   |
| -gt  | 检测左边的数是否大于右边的，如果是，则返回 true。   | `[ $a -gt $b ]`返回false。 |
| -lt  | 检测左边的数是否小于右边的，如果是，则返回 true。   | `[$a -lt $b]`返回 true。   |
| -ge  | 检测左边的数是否大于等于右边的，如果是，则返回 true。 | `[$a -ge $b]` 返回 false。 |
| -le  | 检测左边的数是否小于等于右边的，如果是，则返回 true。 | `[$a -le $b]`返回true。    |

## 数值运算

shell变量默认类型为字符串，可使用以下方法进行数值运算（主要是整数运算）。

- $(())表达式
```shell
a=1
b=2
c=$(($a+$b))
```

- declare
  声明变量类型为整数，以进行运算：
```shell
a=1
declare -i c = $a + 1
echo c    #c为2
```

- expr工具

  `expr 运算式`：（附expr的常用操作）

```shell
expr 100%11    #1  整数运算
expr length "string"    #6  字符串长度
expr substr "this-string" 3 5    #is  在[3,5)区间查找字符串
expr index "string" s   #1  s第一次出现的位置
```

- let工具

`let 运算式`：

```shell
let a=1+1    #a为2
let a++	   #a为3
let a-=2    #a为1
echo $a   # 1
```

## 变量测试

| 变量置换方式        | 变量y没有设置    | 变量y为空值     | 变量           |
| ------------- | ---------- | ---------- | ------------ |
| `x=${y-新值} `  | x=新值       | x为空        | `x=$y`       |
| `x=${y:-新值}`  | x=新值       | x=新值       | `x=$y`       |
| `x=${y+新值}`   | x为空        | x=新值       | x=新值         |
| `x=${y:+新值}`  | x为空        | x为空        | x=新值         |
| `x=${y=新值}`   | x=新值 y=新值  | x为空 y值不变   | `x=$y`  y值不变 |
| `x=${y:=新值}`  | x=新值 y=新值  | x=新值 y=新值  | `x=$y`  y值不变 |
| `x=${y?新值}`   | 新值（标准错误）输出 | x值为空       | `x=$y`       |
| `x=${y:?新值} ` | 新值（标准错误）输出 | 新值（标准错误）输出 | `x=$y`       |

# 正则表达式

**正则表达式与通配符**：

正则表达式是**包含匹配**，用于**文件内容**匹配；通配符是**完全匹配**，多用于**文件名**匹配。

- 支持正则：grep 、cut、sort、awk、sed、uniq
- 只支持通配符不支持正则：find、cp、ls、rm

参看正则表达式和相关工具文档。

# 流程控制

## 条件判断

检查某个条件是否成立，它可以进行文件、数值和字符三个方面的测试。

### 文件判断

- 文件类型判断

`-option file`根据各选项，判断文件的某种情况，返回true或false。
|  选项  | 说明                       |
| :--: | ------------------------ |
|  -b  | 判断文件是否存在，且是否为**块设备**文件   |
|  -c  | 判断文件是否存在，且是否为**字符设备**文件  |
|  -d  | 判断文件是否存在，且是否为**目录**文件    |
|  -e  | 判断文件是否存在                 |
|  -f  | 判断文件是否存在，且是否为**普通**文件    |
|  -L  | 判断文件是否存在，且是否为块**符号链接**文件 |
|  -p  | 判断文件是否存在，且是否为**管道**文件    |
|  -s  | 判断文件是否存在，且是否为非空          |
|  -S  | 判断文件是否存在，且是否为**套接字**文件   |

- 文件权限判断

`-option file`根据各选项，判断某项权限的情况，返回true或false。
|  选项  | 说明                  |
| :--: | ------------------- |
|  -r  | 判断文件是否存在，且是否有读权限    |
|  -w  | 判断文件是否存在，且是否有写权限    |
|  -x  | 判断文件是否存在，且是否有执行权限   |
|  -u  | 判断文件是否存在，且是否有SUID权限 |
|  -g  | 判断文件是否存在，且是否有SGID权限 |
|  -k  | 判断文件是否存在，且是否有SBit权限 |
- 文件对比判断

`file1 -option file2`根据各选项，将第一个文件和第二个文件对比，判断对比情况，返回true/false。
|  选项  | 说明                       |
| :--: | ------------------------ |
| -nt  | 判断文件修改时间是否更新             |
| -ot  | 判断文件修改时间是否更晚             |
| -ef  | 判断文件的Inode是否一致（一致则为同一文件） |
### 整数对比判断
`num1 -option num2`根据各选项，将第一个数和第二个数对比，判断对比情况，返回true/false。
|  选项  | 说明                              |
| :--: | ------------------------------- |
| -eq  | 判断是否相等（equal）                   |
| -ne  | 判断是否不等（not equal）               |
| -gt  | 判断是否更大（greater than）            |
| -lt  | 判断是否更小（less than）               |
| -ge  | 判断是否大于等于（greater than or equal） |
| -le  | 判断是否小于等于（less than or equal）    |
### 字符串判断
空和非空：`-option string` ；等和不等`string1 -option string2`
根据各选项判断字符串情况，返回true或false。

注意：判断是否相等也能用`=` ，但是在`=` 、`==`或`!=`的**两侧一定要有空格**，这一点容易忽略，因为在给变量赋值时不能在等号两边留有空格，故而容易在对比字符串时也不留空格。

|  选项  | 说明     |
| :--: | ------ |
|  -z  | 判断是否为空 |
|  -n  | 判断是否非空 |
|  ==  | 判断是否相等 |
|  !=  | 判断是否不等 |
### 多重条件判断
逻辑或和逻辑与：` expression1 -a expression2`;逻辑非：`!  expression`。
根据选项，进行判断逻辑情况，返回true或false。
|  选项  | 说明   |
| :--: | ---- |
|  -a  | 逻辑与  |
|  -o  | 逻辑或  |
|  !   | 逻辑非  |

## 分支

注意：**在关键字（如if）和中括号`[]`之间必须要有空格** ，**在中括号`[]`和表达式之间也必须有空格**，以及前文所述，判断是否相等时，在`=` 、`==`或`!=`的**两侧一定要有空格**。（后同，不再赘述）

### 单分支

```shell
if [ expression ]
then
	#some codes
fi
#或者这样写
if [ expression ]; then
	#some codes
fi
```
### 双分支

```shell
if [ expression ]
then
	#some codes
else
	#some codes
fi
```
### 多分支
#### 多分支if
```shell
if [ expression ]
then
	#some codes
elif [ expression ]
then
	#some codes
else
	#some codes
fi
```
#### 多分支case
```shell
case var in
value1)
	#some codes
	;;
value2)
	#some codes
	;;
*)	#最后一个默认分支的值使用*
	#some codes
;;
esac
```
## 循环

### for循环

```shell
for var in value1 value2 value3
#for var in $("string")
#for var in $(cat testfile)
#也可以这样写，注意：shell中不能写诸如i+=1或i++
#for ((i=1;i<=100;i=i+1))
do
	#some codes
done
```

### while循环和util循环

- while循环：expression中条件为真时进行循环：

```shell
while(expression)
do
	#some codes
done
```

- until循环：**与while相反**，expression中条件为**假**时进行循环：

```shell
util expression
do
	#some codes
done
```
# 函数

函数格式：

```shell
[ function ] funname [()]{
    # action
    [return int;]
}
```

- `function`关键字可以省略
- 参数返回，可以显示加`return` 返回，如果不加，将以最后一条命令运行结果，作为返回值。 return后跟数值n(0-255）

## 函数参数

通过 `$n` 的形式来获取参数的值，例如`$1`和`$2`， 当n>=10，即从第10可参数起，要以`${n}`的形式书写，如`${10}`和`{11}` 。

处理参数的特殊字符：

- `$#`    传递到脚本的参数个数
- `$*`    以一个单字符串显示所有向脚本传递的参数
- `$@`  与`$*`相同，但是使用时加引号，并在引号中返回每个参数。
  - `$-`  显示Shell使用的当前选项，与set命令功能相同。
  - `$?`  显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。
  - `$$`   脚本运行的当前进程ID号
  - `$!`  后台运行的最后一个进程的ID号

# 引用外部脚本

两种书写格式：

- `. filename `      注意点号`.`和文件名中间有一空格  （如`. .test.sh` ）
- `source filename`    （如` source .test.sh` ）

**注：**被包含的文件可以没有可执行权限。