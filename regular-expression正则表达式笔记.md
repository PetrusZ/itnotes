[TOC]

**正则表达式:r如：ular expression**(R如：ex)，用以匹配和处理文本的字符串，查找和替换特定信息的工具。

根据匹配规则，符合条件的内容会被匹配到并返回（[前后查找](#前后查找)规则可定义符合某匹配条件，但不返回该匹配结果的模式，具体查看该小节介绍）。
# 元字符 

- 特殊字符：在正则表达式中具有特殊意义的字符，如`\` `.` `[ ]` `?` `*` `+`等，它们分别记录在后文各个章节中。

  要去掉特殊字符的特殊含义，只使其代表该字符本身，在字符前面加上`\`。如 `\[`  匹配到了 [

- 空白元字符：匹配空白字符

  | 元字符  | 匹配说明                 |
  | ---- | -------------------- |
  | [\b] | 回退符（backspace键盘）     |
  | \f   | 换页符（form feed）       |
  | \n   | 换行符（new line）        |
  | \r   | 回车符（carriage return） |
  | \t   | 制表符（tab）             |
  | \v   | 垂直制表符（vertical tab）  |

  `\r\n`是一个回车加换行组合，在windows中，它作为文本行的结束标签（结束上段文本并添加一个空白行）。

- 特定字符类别：匹配一类字符

  | 元字符  | 匹配说明                    | 等价表达式         |
  | ---- | ----------------------- | ------------- |
  | \d   | 数字（digit）               | [0-9]         |
  | \D   | 非数字                     | [^0-9]        |
  | \w   | 数字、字母或下划线（word）         | [a-zA-Z0-9_]  |
  | \W   | 非字母、数字或下划线              | [^a-zA-Z0-9_] |
  | \s   | 空白字符（white space）       | [\f\n\r\t\v]  |
  | \S   | 非空白字符                   | [^\f\n\r\t\v] |
  | \x   | 十六进制（hexadecimal digit） |               |
  | \0   | 八进制（Octal digit）        |               |

# 匹配单个字符

- 纯文本：直接使用要匹配的字符。如：`abc` 匹配到了 abc

- 任意字符：任意一个单个字符: `.`   。（一般不匹配换行符）

- 特殊字符：转义符: `\`    （`\.` 匹配 .    `\\` 匹配` \` 自身）。

# 匹配一组字符
- 多个字符中的某一个

  要匹配的字符集合写入`[ ]`中。 如：匹配aac bbc ccc 中的ac和bc：`[ab]c`  匹配到了 aac bbc

- 字符集合区间

  一个字符到另一个字符之间使用 `-` 。如：：`1-9` ` a-z`  `A-Z`等等。

- 不匹配一组字符

  在字符集合最前面写上`^`，该字符集合中所有字符都不被匹配。如：`[^def]` 表示不匹配d、e和f

# 重复匹配

- 匹配到字符的个数：

    - `?`  **0个或1个**

        零个或一个字符（或字符集和）：字符（或字符集和）的零次或一次重复。

    - `+`  **至少1**个

        一个或多个字符（或字符集和）：字符（或字符集和）的一次或多次重复。

    - `*`  **任意**个

        零个或多个字符（或字符集和）：字符（或字符集和）的零次或多次重复。

    重复匹配字符在正则中不能单独使用，而是配合其他字符以表示重复重复n次，在通配符中，`*`则可以单独使用，表示匹配任意个数的字符。

- 匹配要重复次数(number表示数字)：

    - `{number}` 精确的重复次数：精确匹配number次。
    - `{number1,number2}` 区间内的重复次数：至少匹配number1次，至多匹配number2次。
    - `{number,}`至少重复次数：至少重复number次。（次数无上限）


- 防止过度匹配（贪婪匹配和懒惰匹配）

  无上限的匹配字符是一种“贪婪型”元字符（尽可能多地匹配）；

  “贪婪型”元字符加上`?`就成了“懒惰”模式（尽可能少地匹配）：`*?`   `+?`   `{number,}?`

#  边界匹配
- 单词边界  

  - `\b`：匹配某单词的边界（限定单词的开始和结尾，划定\w相匹配的字符的边界）

    如：匹配The **cat** scattered its food中的cat（猫，排除掉scattered）这个词：`\bcat \b`（注意：cat后有空格）

  - `\B`： 不匹配某单词的边界（非单词边界）

    如：`\B - \B` 将匹配一个前后都不是单词的连字符。（因为空格和连字符都不是数字、字母或者下划线，即不属于`\w`）


- 字符串边界

  - 字符开始：`^`
  - 字符串结尾：`$`

  许多正则表达式支持使用一些特殊元字符去改变另外一些元字符的行为，例如：

  分行匹配模式（multiline mode）的**(? m)**记号，使得正则表达式引擎把行分隔符当作一个字符串分隔符来对待。
  如：`(? m)^\s*//.*$` 匹配每一行的//及其后面（仅本行）的字符

# 子表达式
- 子表达式：把正则表达式中某一部分划为一个独立元素进行使用。

  子表达式写在圆括号 **`()`** 之中。
  如：欲匹配两个到多个非折行空格（non-breaking space），即`&nbsp;`，如果使用 `&nbsp;{2，}` ，其匹配的结果是`&nbsp;;;;`这样的文本，因为`{2,}` 是紧挨着`;` 的，应该使用： `(&nbsp;){2,}` ，将`&nbsp;` 作为一个独立的元素。

- 子表达式的嵌套
  如：匹配合法ip地址（数字，0.0.0.0-255.255.255.255，.分隔的每一个区段最大数字是255）。
  `(((\d{1,2})|(1\d{2})|(2[0-4)\d)|(25[0-5]))\.){3}((\d{1,2})|(1\d{2})|(2[0-4]\d)|(25[0-5]))` 

# 回溯引用

回溯引用：正则表达式中，后面的部分**引用**在前面已经定义的**子表达式**。

不同语言有不同的写法，如`$number`,`[number]`,`\number`（number是一个自然数，注意：当number为0，表示整个表达式）。此处以`\number`为示例。 

如：匹配html文件中的h1-h6，如果使用`<[hH][1-6]>.*?</[hH][1-6]>` 则会匹配到 `<h1>一级标题</h2>` 这种情况；利用回溯:`<[hH]（[1-6]）>.*?</[hH]\1>` ，将会在在`</[hH]` 后引用前面已经匹配好的数字，达到前后一致。

**命名捕获** ： 由于Number是对应固定的子表达式位置，如有改动则发生匹配偏差，一种名命名捕获的新的表达式实现出现了，它给子表达式以特殊命名，以示区分。目前此种实现未得到广泛支持。

- 回溯引用用于替换
  简单的替换一般无需正则表达式，在复杂的场合，可先用一个正则表达式找出要替换上的内容，再用一个正则表达式利用回溯引用的简洁替换。

- 大小写转换

| 元字符  | 说明                 |
| ---- | ------------------ |
| \E   | 结束\L或\U转换          |
| \l   | 把下一个字符转换为小写        |
| \L   | 把\L的\E之间的字符全部转换为小写 |
| \u   | 把下一个字符转换为大写        |
| \U   | 把\U到\E之间的字符全部转换为大写 |

# 前后查找
包含匹配的本身**仅用于确定正确的匹配位置**，匹配本身并**不作为匹配结果**的一部分返回。即需要匹配某规则，但是匹配到的内容不作为匹配结果返回。

例如：要匹配后面必须是b的a（即匹配ab），但是又只返回a——`a(?=b)` 。

前后查找返回的结果是0字节，因此，又名零宽度（zero-width）匹配操作。

将前/后查中的`=`换成`!`对其**取非** （可用于排除某种匹配的情况）

| 操作符     | 说明            |
| ------- | ------------- |
| `(?=)`  | 向前查找（正向前查找）   |
| `(?!)`  | 向前查找取非（负向前查找） |
| `(?<=)` | 向后查找（正向后查找）   |
| `(?<!)` | 向后查找取非（负向后查找） |

例子：

- 向前查找：匹配URI中的通信协议（自`:`向前匹配到http和ftp而不包括:本身）

  `.+(?=:)`

- 向后查找：匹配数字，例如一份商品售价单中的价格

   `tamato:$1 potato:$1.5` ，`(?<=\$)[0-9.]+`

- 负向前查找：匹配一串密码—不能全是数字，必须在6到20位

  `(?!\d+$)[\w+-=？*@.]{6,20}`

# 嵌入条件
正则表达式中有时需要嵌入一定的条件进行匹配。嵌入条件用`?(条件)` 。<small>*条件可以是一个子表达式，也可以是一个回溯引用的序列数字，即相应的回溯引用子表达式的位置）*</small>

--如：：将一段html中的`<img>`标签全部找出来，如果`<img>` 是个链接（即`<img>` 位于 `<a></a>` 中），还需要将整个链接标签匹配出来。
`(<[aA]\s)+[^>]+>\s*)?<[iI][mM][gG]\s+[^>]+>(?(1)\s*</[aA]>)`

`(<[aA]\s)+[^>]+>\s*)?`匹配`<a>`或`<A>` 及其任意属性（如果有）；
`<[iI][mM][gG]\s+[^>]+>` 匹配`<img>` 或 `<IMG>`及其属性（如果有）；
`(?(1)\s*</[aA]>)` 是回溯引用条件，`?(1)` 指第一个回溯引用（?(1)中的1前面可以不加\转义），如果`<a>` 或 `<A>` 存在，才利用`\s*</[aA]>` 匹配`</a>` 或`</A>`。 

---

**写正则表达式时，把需要匹配的情况和需要排除的情况都考虑周全，考虑需要匹配的情况比较容易，而考虑周全需要排除的情况往往比较困难。**

---

-POSIX字符类

正则表达式实现支持的一种方式，支持的如vim，grep，python，不支持的如JavaScript。

| 字符类         | 匹配说明                            | 等价表达式         |
| ----------- | ------------------------------- | ------------- |
| [:alnum:]   | 字母或数字                           | [a-zA-Z0-9]   |
| [:alpha:]   | 字母                              | [a-zA-Z]      |
| [:lower:]   | 小写字母                            | [a-z]         |
| [:upper:]   | 大写字母                            | [A-Z]         |
| [:digit:]   | 数字                              | [0-9]         |
| [:blank:]   | 空格或制表符                          | [\t ] （t后有空格） |
| [:cntrl:]   | ASCII控制字符(ASCII 0到31及ASCII 127) |               |
| `[:graph:]` | 同[:print:]                      | [:print:]     |
| [:print:]   | 可打印字符                           |               |
| [:punct:]   | 既不属于[:alnum:]也不属于[:cntrl:]的字符   |               |
| [:space:]   | 空白（包括空格）                        | [^\f\n\r\t\v] |
| [:xdigit:]  | 十六进制数字                          | [a-fA-F0-9]   |